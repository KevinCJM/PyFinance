# 自动化因子挖掘器详细设计文档

## 1. 系统概述

本系统旨在构建一个基于大型语言模型（LLM）的自动化金融因子挖掘平台。通过结合“金融数学家智能体”和“资深Python工程师智能体”，实现从因子构思、代码实现、计算、评估到迭代优化的全流程自动化，并具备自我修复和自我扩展能力。

## 2. 核心组件与角色

### 2.1 数据层 (Data Prepare)

*   **数据来源:** ETF产品的历史数据。
*   **数据格式:** 多个二维数组形式，列表示金融产品，行表示日期。
    *   **基础数据:** 高、低、开、收、成交量、成交额。
    *   **衍生数据:** 日对数收益率等。
*   **数据预处理:**
    *   **缺失值处理:**
        *   **高、低、开、收:** 统一采用**前向填充 (Forward Fill / `ffill`)**。假设在缺失期间价格保持不变。
        *   **成交量、成交额:** 统一采用**零值填充 (Zero Fill)**。表示当日无交易。
        *   **日对数收益率:** 如果原始价格数据已处理，此项应极少缺失。若有，采用**零值填充**。
    *   **异常值处理:**
        *   **高、低、开、收:** 不直接对原始价格进行异常值处理。异常值处理主要针对基于价格计算的**因子值**。
        *   **成交量、成交额:** 统一采用**双侧缩尾 (Winsorization)**，将数据集中位于**1%和99%**分位数之外的值替换为该分位数上的值。
        *   **日对数收益率:** 统一采用**双侧缩尾 (Winsorization)**，将数据集中位于**1%和99%**分位数之外的值替换为该分位数上的值。
    *   **标准化/中性化:**
        *   **高、低、开、收、成交量、成交额、日对数收益率:** 原始数据不进行标准化。标准化处理主要针对**因子值**。
        *   **因子值标准化 (Cross-sectional Standardization):**
            *   对每个交易日的所有金融产品，将因子值进行**Z-score 标准化**，转换为均值为0、标准差为1的分布。公式：`Z = (X - mean(X)) / std(X)`。
            *   **考量:** 这是因子计算后，进行评估前的标准步骤，确保因子值在不同股票之间具有可比性，并消除量纲影响。
        *   **行业/市值中性化 (Industry/Market Cap Neutralization):**
            *   **目的:** 消除因子中包含的行业、市值等常见风险因子暴露，以隔离纯粹的Alpha收益。
            *   **方法:** 采用**线性回归**。将因子值作为因变量，将行业哑变量（或行业分类变量）、市值（或市值分位数）等作为自变量进行回归。回归的残差即为中性化后的因子值。
            *   **考量:** 中性化是构建高质量Alpha因子的关键步骤，有助于降低组合的系统性风险，并提高因子的独立性。


### 2.2 算子库 (Operator Library)

*   **功能:** 提供因子计算所需的基础数学和统计算子。
*   **特点:**
    *   **向量化支持:** 所有算子底层实现均采用NumPy或Pandas等库进行向量化操作，以确保高性能。
    *   **参数支持:** 算子入参支持其在数学上能够支持的参数（例如：自由度、上下限等）。
    *   **可扩展性:** 允许动态添加新算子。
*   **算子类型 (包括但不限于):**
    *   **基础数学算子:** 加、减、乘、除、对数（log）、绝对值（abs）、幂（power）、平方根（sqrt）等。
    *   **累积算子:** 累加（sum）、累乘（prod）、累积最大值（cummax）、累积最小值（cummin）等。
    *   **统计算子:** 均值（mean）、标准差（std）、方差（var）、相关系数（corr）、协方差（cov）、最大值（max）、最小值（min）、中位数（median）、分位数（quantile）等。
    *   **时间序列算子:** 移动平均（moving_average）、指数移动平均（ema）、滚动排名（rolling_rank）、时间序列衰减加权平均（time_series_decay）等。
    *   **数据预处理算子:** 中性化（neutralize）、缩尾（winsorize）、截断（clip）、缺失值填充（fillna）、横截面排名（rank）、横截面标准化（scale）等。

### 2.3 智能体 (Agents)

#### 2.3.1 金融数学家智能体 (Financial Mathematician Agent)

*   **角色:** 负责因子构思、逻辑生成和新算子需求提出。
*   **输入:**
    *   当前可用的算子列表及其详细说明。
    *   历史对话中的因子成果（因子公式、评估结果、成功/失败案例等）。
    *   当前迭代的评估结果。
*   **输出:**
    *   **因子计算逻辑 (JSON):**
        ```json
        {
          "des": "因子解释",
          "ast": "AST语法树 (表示因子计算逻辑)",
          "latex": "AST对应的LaTex数学公式"
        }
        ```
    *   **新算子需求 (JSON):**
        ```json
        {
          "action": "CreateNewCalFunc",
          "function_name": "新函数名",
          "description": "新函数的功能描述，包括输入、输出、数学逻辑等详细信息",
          "example_usage": "一个使用新函数的代码示例"
        }
        ```
*   **Prompt工程策略:**
    *   **明确算子列表:** 每次调用时，在Prompt中明确提供当前所有可用的基础算子及其参数说明。
    *   **优质范例 (Few-shot Prompting):** 提供高质量的、已被证明有效或结构优秀的因子作为范例，引导LLM生成类似结构的因子。
    *   **复杂度控制:** 引导LLM生成复杂度可控的因子，避免过拟合。
    *   **探索与利用平衡:** 鼓励探索新颖的因子结构，同时利用已知有效模式。
    *   **新算子需求引导:** 明确告知其提出新算子需求的格式和时机。

#### 2.3.2 资深Python工程师智能体 (Senior Python Engineer Agent)

*   **角色:** 负责代码审查、缺陷修改、新算子开发与测试。
*   **输入:**
    *   程序报错信息（包括堆栈跟踪）。
    *   相关代码片段。
    *   新算子需求（来自金融数学家智能体）。
*   **输出:**
    *   **代码修改指令:** 使用`EditFile`、`CreateFile`等工具进行文件操作。
    *   **新算子实现及测试结果确认。**
*   **工具集:** `ReadFile`, `SearchText`, `FindFile`, `EditFile`, `CreateFile`, `Shell`。
*   **Prompt工程策略:**
    *   **明确任务:** 针对报错修复或新算子开发，明确其任务目标。
    *   **提供上下文:** 尽可能提供详细的错误信息、相关代码和文件路径。
    *   **要求测试:** 强调在修改或开发后，必须编写并运行相应的单元测试。
    *   **输出确认:** 要求其在完成任务后返回明确的确认信息。
*   **错误处理策略:**
    *   **分类处理:** 区分简单错误（如除零）和复杂逻辑错误。简单错误可优先通过预设规则处理，复杂错误再交由LLM。
    *   **成本优化:** 对于高频同类错误，可建立缓存或规则库，减少LLM调用。
    *   **安全性与回滚:** 每次修改前记录文件状态，以便在修改失败时回滚。

## 3. 流程设计

### 0. 数据准备

*   加载高、低、开、收、成交量、成交额等基础数据。
*   计算日对数收益率等衍生数据。
*   对数据进行预处理（缺失值填充、异常值处理、标准化/中性化等）。

### 1. 算子库初始化与管理

*   系统启动时加载现有算子库。
*   维护一个可用的算子列表，包括函数名、参数、功能描述等。

### 2. 因子构思与生成 (金融数学家智能体)

*   **输入:** 当前算子列表、历史因子成果摘要、当前迭代评估结果。
*   **过程:**
    1.  调用“金融数学家智能体”，要求其根据输入构思新的因子计算逻辑。
    2.  “金融数学家智能体”返回JSON格式的输出。
*   **输出解析:**
    1.  程序解析“金融数学家智能体”的输出。
    2.  **如果输出是因子计算逻辑JSON:** 继续步骤3。
    3.  **如果输出是新算子需求JSON (`CreateNewCalFunc`):**
        *   暂停因子挖掘循环。
        *   将新算子需求传递给“资深Python工程师智能体”（跳转到步骤2.1）。

### 2.1 新算子开发与测试 (资深Python工程师智能体)

*   **输入:** 新算子需求（`function_name`, `description`, `example_usage`）。
*   **过程:**
    1.  调用“资深Python工程师智能体”，要求其根据需求在算子库中实现新函数。
    2.  “资深Python工程师智能体”使用`EditFile`或`CreateFile`工具编写代码，并编写单元测试。
    3.  运行单元测试验证新算子功能。
*   **输出:**
    1.  “资深Python工程师智能体”返回完成确认信息。
    2.  程序更新内部算子列表，重新加载算子模块。
    3.  返回步骤2，让“金融数学家智能体”使用新算子继续构思因子。
*   **错误处理:** 如果新算子开发失败，通知用户，并可选择回滚或跳过该需求。

### 3. AST解析与IR-DAG生成

*   程序解析“金融数学家智能体”返回的AST语法树。
*   将AST转换为中间表示（IR）的定向无环图（DAG），表示因子计算的执行计划。
*   进行计算优化（例如，公共子表达式消除）。

### 4. 因子计算

*   根据IR-DAG执行因子计算。
*   **运行时错误监控:**
    *   在计算过程中，如果程序发生报错（例如，除零、数据类型不匹配等）。
    *   **错误分类:** 优先尝试通过预设的规则（如除零返回NaN）处理简单、可预见的错误。
    *   **LLM介入:** 对于无法通过规则处理的错误，捕获报错内容（堆栈跟踪、错误信息、相关代码片段）。
    *   **调用“资深Python工程师智能体”:** 将报错信息传递给“资深Python工程师智能体”（跳转到步骤4.1）。

### 4.1 代码审查与缺陷修改 (资深Python工程师智能体)

*   **输入:** 报错信息、相关代码片段。
*   **过程:**
    1.  调用“资深Python工程师智能体”，要求其理解报错内容，对代码进行审查，并提出修改方案。
    2.  “资深Python工程师智能体”使用`EditFile`工具修改代码。
    3.  （可选）运行修改后的代码片段进行快速验证。
*   **输出:**
    1.  “资深Python工程师智能体”返回修改完成确认信息。
    2.  程序重新尝试执行因子计算（返回步骤4）。
*   **错误处理:** 如果多次尝试修复仍失败，通知用户，并可选择跳过当前因子或终止。

### 5. 因子有效性评估

*   当所有金融产品的数据都计算完成后，对该因子进行有效性评估。
*   **评估指标:**
    *   Normal IC (信息系数)
    *   Rank IC (秩信息系数)
    *   t检验
    *   分组收益回测
    *   分组夏普回测
    *   IR (信息比率)
    *   Alpha
    *   Beta
    *   **因子相关性:** 计算新因子与已有因子库中所有因子之间的相关性，标记冗余因子。
*   **评估过程中的错误监控:** 同样使用“资深Python工程师智能体”作为监护，处理评估过程中的任何程序报错（同步骤4.1）。

### 6. 因子成果解析与新因子构造迭代 (金融数学家智能体)

*   **输入:** 当前因子的详细评估结果。
*   **过程:**
    1.  调用“金融数学家智能体”，要求其解析因子成果。
    2.  基于当前因子成果以及历史对话中的因子成果摘要，重新提出新的因子构造逻辑JSON。
*   **输出:** 新的因子计算逻辑JSON（返回步骤2）。

### 7. 自动化循环与终止条件

*   **自动化重复:** 自动化重复因子构造的循环过程（步骤2到步骤6）。
*   **终止条件:**
    1.  **因子有效性达到阈值:** 例如，连续N个因子的Rank IC均值超过某个预设值。
    2.  **循环次数达到阈值:** 达到预设的最大迭代次数。
    3.  **LLM Token超限:** 由于历史对话的增加，“金融数学家智能体”的Token使用量达到预设上限。
    4.  **人工干预:** 用户手动终止。

### 8. 自动化日志功能

*   **日志内容:**
    *   程序执行日志（包括时间戳、模块、级别、消息）。
    *   “金融数学家智能体”的输入、输出、构思过程。
    *   “资深Python工程师智能体”的输入、输出、修改内容、修复结果。
    *   每次迭代的因子公式、AST、LaTeX、评估结果。
    *   新算子开发请求及实现过程。
*   **日志存储:** 结构化存储（例如，JSON文件、数据库），便于后续分析和回溯。

## 4. 技术栈 (示例)

*   **核心语言:** Python
*   **数据处理:** Pandas, NumPy
*   **因子计算:** 基于Pandas/NumPy的向量化实现
*   **LLM接口:** OpenAI API, Gemini API 或其他LLM服务
*   **AST解析:** Python `ast` 模块或其他自定义解析器
*   **IR-DAG:** NetworkX 或自定义图结构
*   **日志:** Python `logging` 模块
*   **版本控制:** Git (用于代码和算子库管理)

## 5. 风险与挑战

*   **LLM的幻觉与不确定性:** LLM可能生成语法错误、逻辑不通或无法实现的因子逻辑。需要强大的解析、验证和错误修复机制。
*   **性能瓶颈:** 大规模金融数据计算对性能要求极高，需要确保算子库和计算引擎的高度优化。
*   **过拟合风险:** 自动化生成的因子可能在历史数据上表现良好，但在未来数据上失效。需要严格的评估和交叉验证。
*   **成本控制:** LLM API调用成本可能较高，需要精细的调用策略和预算管理。
*   **算子库的安全性与稳定性:** 允许LLM修改核心代码库存在风险，需要严格的测试和人工审核。
*   **可解释性:** 自动化生成的复杂因子可能难以解释其经济学含义。

## 6. 未来展望

*   **多模态输入:** 允许LLM参考图表、报告等非结构化数据。
*   **强化学习:** 结合强化学习，让系统在因子挖掘过程中学习更好的策略。
*   **分布式计算:** 支持在分布式集群上进行大规模因子计算和回测。
*   **可视化界面:** 提供友好的用户界面，展示因子挖掘进度、评估结果和因子库。
*   **更智能的终止条件:** 基于因子组合优化、风险预算等更复杂的条件。
*   **人类在环 (Human-in-the-Loop):** 允许人类专家在关键节点进行干预、审核和指导。
