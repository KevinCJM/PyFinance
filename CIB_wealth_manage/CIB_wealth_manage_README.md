# CIB Wealth Management Code Analysis

## 1. 功能概述

该代码库实现了一个复杂的财富管理系统，其核心功能是**构建和优化投资组合**。它根据一系列输入参数（如客户风险偏好、投资金额、市场数据、产品特性等），利用数学规划（特别是混合整数规划）的方法，为客户生成一个或多个最优的投资组合方案。

该系统不仅能从零开始构建新组合，还能对客户的现有持仓进行分析和调整，支持“微调”和“管销”等特殊业务场景。整个系统既可以作为独立的计算引擎，也通过 Flask 框架封装为 Web 服务，提供 API 接口。

## 2. 输入与输出

### 主要输入

1.  **客户信息 (Client Info):**
    *   `cpkAmount`: 客户总投资金额。
    *   `risk`: 客户的风险等级。
    *   `userHoldingDict`: 客户的现有持仓产品列表及其详细信息（如持仓金额、是否可买卖、剩余期限等）。
    *   `privateVisible`: 是否为合格投资者。
    *   `pref`: 客户对大类资产的偏好。

2.  **产品信息 (Products):**
    *   `products`: 可投资的产品池列表，包含每个产品的详细属性（如起购金额、递增金额、风险等级、所属大类资产、业绩基准等）。

3.  **市场数据 (Market Data):**
    *   `matrixBaseCodeArray`: 资产的基准指数代码列表。
    *   `matrix`: 资产收益率的协方差矩阵。
    *   `indexReturn`: 各资产的预期收益率。

4.  **模型与策略参数 (Model & Strategy Params):**
    *   `clazzCfg`: 目标大类资产配置比例（如现金类 5%，固收类 20%...）。
    *   `maxAllowedDev`: 各大类资产允许的最大偏离度。
    *   `scoreWeight`: 多目标优化中不同优化目标的权重（如流动性、收益、风险的权重）。
    *   `holdAfterYearStdWeight`, `prodCrWeight`: 风险评分中，波动率和分散度的权重。
    *   `scoreFunction`, `scoreArgs`: 各项指标评分所使用的非线性函数及其参数。
    *   `productsCountRangeInOneCpk`: 组合中产品数量的上下限。
    *   `longest_idle_time`: 组合允许的最大久期。
    *   `max_weight`: 单一资产类别的最大持仓权重。

### 主要输出

1.  **投资组合 (Portfolios):**
    *   一个或多个推荐的投资组合方案。每个方案是一个产品列表，包含：
        *   `产品ID`: Product ID.
        *   `持仓权重`: Weight of the product in the portfolio.
        *   `持仓金额`: Amount of the product to hold.

2.  **组合指标 (Indicators):**
    *   `durationAfter`/`Before`: 调仓后/前的组合久期。
    *   `cashRatioAfter`/`Before`: 调仓后/前的现金类资产占比。
    *   `returnAfter`/`Before`: 调仓后/前的预期收益率。
    *   `volatilityAfter`/`Before`: 调仓后/前的预期波动率。
    *   `disperseAfter`/`Before`: 调仓后/前的分散度。
    *   `cashScoreAfter`/`Before`, `returnScoreAfter`/`Before`, `volatilityScoreAfter`/`Before`, `disperseScoreAfter`/`Before`: 三性评分对应的分数。
    *   `finalScoreAfter`/`Before`: 最终的组合总分。

3.  **消息与日志 (Messages & Info):**
    *   `errorMsg`: 优化过程中出现的错误或警告信息。
    *   `info`: 优化过程的详细日志，包括求解器状态、耗时、约束检查结果等。

## 2.1. 输入参数详解 (test_json)

本节详细解析 `start.py` 中 `test_json` 变量定义的各项输入参数，这些参数共同构成了优化模型的完整输入。

### 顶层结构

-   `configs`: 一个列表，允许多个配置任务批量执行。测试用例中只包含一个配置对象。
-   `f`: 字符串，指定了在 `views.wealth_manage.WealthManage` 类中需要调用的方法名，例如 `"investment_portfolio_individual_m4_auto_establish_v2"`。

### `configs` 对象内部参数

#### 客户与基本配置

| 参数 | 示例值 | 含义与作用 |
| :--- | :--- | :--- |
| `cpkAmount` | `1000000.0` | **总投资金额**。定义了整个投资组合的预算总额。 |
| `risk` | `6` | **客户风险等级**。用于筛选符合风险要求的产品。 |
| `privateVisible` | `1` | **合格投资者标识**。`1`表示是，`0`表示否。用于过滤特定产品。 |
| `userHoldingDict` | `[...]` | **客户现有持仓**。一个产品对象列表，包含客户已持有的资产及其状态（如金额、是否可买卖），是进行调仓优化的基础。 |
| `portfolio_num` | `1` | **期望生成的组合数量**。模型会尝试生成指定数量的、有差异的最优组合方案。 |
| `index` | `"0011_999000"` | **任务唯一标识**。用于日志记录和问题追溯。 |

#### 市场与产品数据

| 参数 | 示例值 | 含义与作用 |
| :--- | :--- | :--- |
| `matrixBaseCodeArray` | `["885000.WI", ...]` | **资产基准指数代码列表**。定义了协方差矩阵的行和列所对应的资产基准。 |
| `matrix` | `[[0.053,...],...]` | **协方差矩阵**。一个N*N的矩阵，描述了`matrixBaseCodeArray`中各个资产收益率之间的相关性，是计算组合波动率的核心数据。 |
| `products` | `[{...}, ...]` | **可投资产品池**。一个产品对象列表，包含了所有可用于构建组合的备选产品及其详细属性（如ID、名称、风险等级、起购金额、递增金额、所属大类、关联的基准指数代码等）。 |
| `rf` | `0.0175` | **无风险利率** (Risk-Free Rate)。主要用于计算夏普比率等衍生指标。 |

#### 模型与策略参数

| 参数 | 示例值 | 含义与作用 |
| :--- | :--- | :--- |
| `clazzCfg` | `{"clazz01": 0.05, ...}` | **目标大类资产配置**。定义了战略资产配置目标，即各大类资产（现金、固收、权益等）在组合中应占的理想权重。这是模型最重要的约束之一。 |
| `maxAllowedDev` | `{"clazz01": 0.20, ...}` | **大类资产最大允许偏离度**。允许最终生成组合的大类资产权重在`clazzCfg`目标的基础上浮动的百分比。例如，目标20%，偏离度20%，则允许范围为16%-24%。 |
| `max_weight` | `{"clazz01": 0.25, ...}` | **单一产品持仓上限**。定义了**单个产品**在其所属大类资产中的最大权重。这是防止单个产品持仓过于集中的关键风控约束。 |
| `productContRangeInOneCpk` | `[1, 12]` | **组合产品数量范围**。约束最终组合包含的产品数量必须在此区间内（例如，最少1个，最多12个）。 |
| `cpkAllowedCloseDay` | `657` | **组合允许的最大久期**。约束了组合的加权平均资金锁定时间（天），用于控制组合的流动性。 |
| `scoreWeight` | `[0.2, 0.5, 0.3...]` | **一级目标权重**。分别对应 **[流动性, 收益, 风险]** 三个一级目标在最终总分计算中所占的权重。 |
| `holdAfterYearStdWeight` | `0.7` | **二级目标权重（波动率）**。在“风险”这个一级目标下，波动率评分所占的权重。 |
| `prodCrWeight` | `0.3` | **二级目标权重（分散度）**。在“风险”这个一级目标下，分散度评分所占的权重。风险总分 = `holdAfterYearStdWeight` * 波动率分 + `prodCrWeight` * 分散度分。 |
| `isFineTuning` | `False` | **是否微调模式**。若为`True`，则会启用`finetuning_config_setting.py`中的逻辑，根据用户偏好`pref`调整约束。 |
| `pref` | `None` | **客户大类资产偏好**。一个以逗号分隔的资产类别代码字符串，在`isFineTuning`为`True`时生效。 |
| `intereScoreDict` | `{}` | **兴趣分字典**。一个`产品三级分类码 -> 分数`的映射，允许为特定产品类型人为增加“兴趣分”，从而在优化中提高其被选中的概率。 |

### `products` 内部参数详解

`products` 列表定义了所有可供优化器选择的投资产品，每个产品对象包含以下关键参数：

| 参数 | 示例值 | 含义与作用 |
| :--- | :--- | :--- |
| `productId` | `"019B310006"` | **产品唯一标识符**。 |
| `productName` | `"添利新私享"` | **产品名称**。 |
| `risk` | `"1"` | **产品风险等级**。用于匹配客户风险承受能力。 |
| `level` | `5.0` | **产品评级**。可以作为优化目标之一，评级越高的产品越优。 |
| `clazz` | `"01"` | **大类资产编码**。将产品归类到现金、固收、权益等大类，用于匹配`clazzCfg`约束。 |
| `sjdy` | `"01002002"` | **三级分类码值**。更精细的产品分类，用于匹配`product_priority.csv`等配置规则。 |
| `amount` | `0.00` | **起购金额**。约束条件，任何对此产品的投资都不能低于此金额。 |
| `incAmt` | `1.00` | **递增金额**。投资金额必须是`起购金额 + N * 递增金额`的形式。对于非整数规划，此参数影响较小。 |
| `closeDays` | `1.0` | **产品封闭期**（天）。用于计算组合的久期。 |
| `baseCode` | `"H11025.CSI"` | **关联的基准指数代码**。用于从`matrix`中查找该产品的波动率和相关性数据。 |
| `baseRate` | `0.022` | **预期收益率**。该产品的预期回报，是计算组合总收益的核心数据。 |
| `zgcyje` | `10000000.00` | **最高持有金额**。约束单个客户持有该产品的金额上限。 |
| `isRecomm` | `False` | **是否重点推荐**。布尔值，可以在优化目标中为重点推荐产品增加得分。 |

### `userHoldingDict` 内部参数详解

`userHoldingDict` 列表定义了客户的现有持仓，是进行**调仓 (Rebalancing)** 而非新建仓时的关键输入。其内部参数与`products`类似，但更侧重于描述**持仓状态**。

| 参数 | 示例值 | 含义与作用 |
| :--- | :--- | :--- |
| `productId` | `"_TMP_XJ_FIXED"` | **持仓资产的唯一ID**。 |
| `asset` | `0.0` | **当前持仓金额**。这是计算调仓成本和换手率的基础。 |
| `is_can_sell` | `True` | **是否可卖出**。**核心约束**。若为`False`，优化器不能减少该产品的持仓金额。 |
| `is_can_buy` | `True` | **是否可买入**。若为`False`，优化器不能增加该产品的持仓金额。 |
| `remain_term` | `0` | **剩余期限**（天）。用于精确计算现有持仓的久期。 |
| `productName` | `"现金"` | **持仓资产名称**。 |
| `sjdy` | `"01001001"` | **三级分类码值**。用于将持仓资产进行分类。 |
| `baseCode` | `"XYHQCK"` | **关联的基准指数代码**。 |

### 评分体系参数 (`scoreFunction` 和 `scoreArgs`)

这两个参数共同定义了模型如何将原始的投资指标（如收益率、波动率）转换为0-100分的得分，是优化目标函数的核心。

-   `scoreFunction`: 一个包含四个函数名的列表，**顺序是固定的**，分别对应：
    1.  `现金类占比评分`
    2.  `预期收益率评分`
    3.  `预期波动率评分`
    4.  `分散度评分`

-   `scoreArgs`: 一个包含四个列表的参数矩阵。每个内部列表都是一组参数 `[a, b, c, d, k, t]`，与 `scoreFunction` 按顺序一一对应，用于控制评分曲线的形状。

**示例解析**:

| 指标 | `scoreFunction` | `scoreArgs` | 含义 |
| :--- | :--- | :--- | :--- |
| 现金类占比 | `"atan"` | `[68.04, ..., 0.0]` | 使用反正切函数 (`arctan`) 对现金占比进行评分。 |
| 预期收益率 | `"morgan_mercer_flodin_customreturn"` | `[100.0, ..., 0.0]` | 使用一种S型生长曲线对预期收益率进行评分。 |
| 预期波动率 | `"tanh_neg"` | `[86.79, ..., 0.0]` | 使用负双曲正切函数 (`-tanh`) 对波动率进行评分（波动率越高，得分越低）。 |
| 分散度 | `"morgan_mercer_flodin"` | `[100.0, ..., 0.0]` | 使用S型生长曲线对分散度指标进行评分。 |

### 全局策略参数 (`globalTurn`)

`globalTurn` 对象包含了一系列用于描述全局性策略或高级约束的键值对。**但在当前的代码实现中，这些参数并未在核心优化逻辑（如 `constructPortfolioIndividualM4.py`）中被直接使用**。它们很可能用于更高层次的业务流程，或者为未来功能预留的接口。

| 参数 | 示例值 | 可能的含义（基于名称推断） |
| :--- | :--- | :--- |
| `turnOverMinimize` | `1` | 意图最小化换手率。 |
| `totalScoreMaximize` | `1` | 意图最大化组合总分。 |
| `itemScoreThreshold` | `80` | 可能用于设置某个或所有子项分数的最低门槛。 |
| `recommSumMaximize` | `1` | 意图最大化组合中重点推荐产品的总权重或数量。 |

## 3. 代码整体架构

该系统的架构可以分为以下几个层次：

1.  **表示层 (Presentation Layer):**
    *   `start.py`: Flask Web 服务器的启动入口。
    *   `views/`: 包含 Flask 的视图（View）和路由（Route）定义。`wealth_manage.py` 定义了 `/wealth_manage` 路由，并处理 HTTP 请求。
    *   `server/`: 包含 Flask 应用实例 (`base.py`) 和服务层 (`service.py`)。

2.  **服务层 (Service Layer):**
    *   `service.py`: 封装了核心的业务逻辑。它定义了一个 `Service` 类，其中的 `build_investment_portfolio_individual_m4` 方法是构建个人投资组合功能的主要入口，负责调用底层的计算和优化模块。

3.  **核心计算与优化层 (Core Logic Layer):**
    *   位于 `calculate/` 目录下，是整个系统的核心。
    *   **主流程控制 (`investment_portfolios_individual_m4.py`, `opti_functions.py`):** 负责编排整个优化流程，包括数据预处理、参数调整、调用优化器、后处理等。
    *   **优化模型定义 (`constructPortfolioIndividualM4.py`):** 使用 `cvxpy` 库定义了混合整数规划问题。这里是定义决策变量、目标函数和约束条件的地方。
    *   **目标函数 (`object_functions.py`):** 定义了优化模型要最大化的目标。这是一个由多个子目标（如收益、风险、流动性等）加权构成的复合函数。
    *   **约束条件 (`constratints.py`):** 定义了优化必须遵守的所有规则，如预算约束、大类资产比例约束、产品数量约束、久期约束等。
    *   **指标计算 (`indicator_calculate.py`):** 负责在优化前后计算投资组合的各项性能指标。
    *   **基础数学函数 (`base_functions.py`):** 提供了一些基础的数学工具，特别是评分函数的具体实现。
    *   **参数与场景处理 (`finetuning_config_setting.py`, `sellproduct_config_setting.py`, `param_check_func.py`):** 根据不同的业务场景（如微调、管销）动态调整优化参数和约束。
    *   **数据与配置 (`config/`, `product_class.csv`):** 存放静态配置文件，如产品优先级、分散度计算的排除列表等。

4.  **工具层 (Utility Layer):**
    *   `utils/`: 提供通用工具，如错误处理 (`errors.py`) 和超时限制 (`limit.py`)。

## 4. 各 py 文件核心功能

| 文件路径                                                     | 核心功能                                                                                                                            |
| :----------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------- |
| **`investment_portfolios_individual_m4.py`**                 | **总入口和主控制器**。接收所有输入，调用产品过滤、参数设置、优化执行等一系列流程，是整个计算任务的“大脑”。                      |
| **`constructPortfolioIndividualM4.py`**                      | **优化模型构建器**。使用 `cvxpy` 定义决策变量（如各产品的权重 `w`、是否购买 `z` 等），并调用 `ObjectScoreCal` 和 `ConstraintsClass` 来组装最终的优化问题。 |
| **`object_functions.py`**                                    | **目标函数定义**。`ObjectScoreCal` 类定义了需要优化的各个子目标，如收益分、流动性分、波动率分、分散度分、换手率等。             |
| **`constratints.py`**                                        | **约束条件集合**。`ConstraintsClass` 类定义了所有业务规则和限制，例如预算、大类资产比例、产品数量、久期、交易限制等。         |
| **`opti_functions.py`**                                      | **优化执行与检查**。`do_one` 函数负责执行一次完整的优化求解。`ConstraintsCheck` 类用于在优化失败时，逐一放宽约束以定位问题。 |
| **`indicator_calculate.py`**                                 | **组合指标计算器**。用于在优化完成后，计算新旧组合的各项表现指标（收益、风险、久期等）及其得分。                               |
| **`base_functions.py`**                                      | **基础数学函数库**。提供了底层的评分函数（如 `arctan`, `tanh`）和求根函数，是所有评分计算的基础。                               |
| **`score_estimate.py`**                                      | **指标范围估算器**。在正式优化前，通过简化的线性规划快速估算各项指标（如收益率、波动率）可能达到的最大/最小值，为后续评分函数的线性近似做准备。 |
| `finetuning_config_setting.py`                               | **微调场景处理器**。当客户有特定资产偏好时，该模块会调整约束和目标权重，以引导优化结果偏向客户喜欢的资产类别。               |
| `sellproduct_config_setting.py`                              | **管销场景处理器**。为特定的营销场景调整优化参数。                                                                                |
| `param_check_func.py`                                        | **参数调整器**。根据客户现有持仓中不可卖出的部分，动态调整大类资产配置目标和久期约束，确保优化问题有可行解。                 |
| `product_filter.py`                                          | **产品过滤器**。根据产品的三级分类码，设置产品是否可买入。                                                                      |
| `portfolio_adjust.py`                                        | **精度调整器**。优化求解器得到的结果是浮点数，该模块负责对结果进行取整和微调，以满足实际交易中最小金额单位的要求。           |
| `config_py.py`                                               | **全局配置文件**。定义了资产类别代码、评分函数名称等全局常量。                                                                  |
| `local_test.py`                                              | **本地测试脚本**。提供了一个本地运行的入口，加载示例数据并调用核心优化逻辑，方便开发和调试。                                    |
| `start.py`, `service.py`, `views/*`, `server/*`               | **Web 服务层**。使用 Flask 框架将核心功能封装成 API 服务，使其可以被其他系统调用。                                                |

## 5. 优化器的优化目标和约束

### 优化目标 (Objective Function)

优化器的核心目标是**最大化一个综合评分 `Obj`**。这个综合评分是多个子目标的加权和，定义在 `constructPortfolioIndividualM4.py` 中。

`Obj = w_return * score_return + w_cash * score_cash + w_vol * score_vol + w_disperse * score_disperse + ...`

主要子目标包括：

*   **收益率 (`收益率`)**: 预期收益率越高越好。
*   **流动性 (`流动性`)**: 现金类资产占比越高越好。
*   **波动率 (`波动率`)**: 组合的预期波动率越低越好。
*   **分散度 (`分散度`)**: 组合的持仓越分散越好（避免集中在少数几个产品上）。
*   **换手费率 (`换手费率`)**: 调仓操作（买入/卖出）产生的费用越低越好。
*   **产品数量 (`产品数量`)**: 使产品数量在一个合理范围内，避免过多或过少。
*   **久期 (`久期`)**: 组合的资金锁定时间。
*   **调仓数量 (`调仓数量`)**: 发生交易的产品数量越少越好。
*   **其他**: 还包括产品评级、重点推荐、兴趣评分等软性指标。

每个子目标的权重 (`w_return`, `w_cash` 等) 在输入参数 `ObjAlloc` 中指定，这使得模型可以根据不同的投资策略调整优化方向。

### 约束 (Constraints)

优化过程必须在 `constratints.py` 中定义的一系列严格约束下进行，确保生成的组合是**可行且合规的**。

**核心约束包括：**

1.  **基本约束 (`base_constraint`):**
    *   每个产品只能处于“买入”、“卖出”、“持有”三种状态之一。
    *   正确处理重复产品（同一产品在持仓中出现多次）的买卖逻辑。
    *   正确计算增持 (`w_inc`) 和减持 (`w_dec`) 的比例。

2.  **预算约束 (`budget_constraint`):**
    *   所有产品的持仓权重之和必须在一个预设范围内（例如，大于 95%，小于 100%）。

3.  **持仓金额/权重约束 (`one_amount_constraint`, `class_bound_constraint`):**
    *   **单产品**: 每个产品的投资金额必须介于其最小起购金额和最大可投金额之间。
    *   **大类资产**: 每类资产（如权益类、固收类）的总权重必须在目标配置上下浮动范围内 (`target_asset_alloc` ± `asset_alloc_bias`)。

4.  **交易与持仓逻辑约束 (`hold_amount_constraint`):**
    *   对于已持仓产品，买入或卖出有最小金额限制。
    *   对于“不可卖出”的产品，其最终持仓金额不能低于当前持仓金额。
    *   对于“不可买入”的产品，其最终持仓金额不能高于当前持仓金额。
    *   对于“既不能买入也不能卖出”的产品，其持仓金额必须保持不变。

5.  **组合特征约束:**
    *   **产品数量 (`portfolios_products_num_constraint`):** 组合中的产品总数必须在指定的最小和最大数量之间。
    *   **久期 (`portfolios_duration_constraint`):** 组合的加权平均久期不能超过设定的最长闲置时间。

6.  **分数约束 (`return_score_constraint`, `cash_score_constraint`):**
    *   可以设置某些指标得分的下限，例如要求最终组合的“收益分”不得低于某个阈值。

## 6. 评分函数 (Scoring Function)

### 作用

评分函数的核心作用是将一个**原始的、无界的业务指标**（如预期收益率、波动率）**转换为一个有界的、归一化的分数**（通常在 0-100 分之间）。

这种转换至关重要，因为它解决了两个问题：
1.  **可比性**: 不同指标的量纲和范围差异巨大（例如，收益率可能是 5%，波动率可能是 15%，分散度可能是 1.2）。将它们转换为统一的“分数”后，才能放在同一个目标函数里进行加权求和。
2.  **非线性关系**: 投资决策中的“满意度”通常不是线性的。例如，收益率从 2% 提升到 4% 带来的满意度提升，远大于从 20% 提升到 22%。评分函数通过使用 `arctan`, `tanh` 等非线性函数，可以很好地模拟这种边际效用递减的现象。

### 逻辑

1.  **函数选择**:
    *   代码在 `base_functions.py` 的 `funRun` 函数中预定义了几种评分函数，如 `arctan` (反正切函数), `tanh_neg` (反双曲正切函数), `morgan_mercer_flodin` (一种S型生长曲线函数)。
    *   这些函数都是 **S 型曲线**，具有两端平缓、中间陡峭的特点，非常适合模拟满意度评分。

2.  **参数化**:
    *   每个评分函数都有一组参数 (`a, b, c, d, k, t`)，这些参数在输入 `scoreArgs` 中提供。
    *   通过调整这些参数，可以控制 S 型曲线的**形状、位置和范围**，使其精确地将预期的指标范围 (例如，收益率从 2% 到 15%) 映射到期望的分数范围 (例如，从 20 分到 90 分)。

3.  **线性近似 (`object_functions.py`):**
    *   由于 `cvxpy` 这类凸优化求解器处理非线性目标函数的能力有限，代码采用了一种聪明的近似方法。
    *   在 `object_functions.py` 中，它首先调用 `score_estimate.py` 估算出每个指标（如收益率）的实际可能取值范围（最小值 `min_value` 和最大值 `max_value`）。
    *   然后，它计算出这两个端点对应的分数（`min_score` 和 `max_score`）。
    *   最后，它用**连接这两个端点的直线**来近似这段S型曲线。这样，非线性的评分问题就被转换成了一个**线性函数 `k * x + b`**，从而可以被求解器高效处理。

    **简而言之，评分函数的逻辑是：用一条直线来近似一段关键区间的S型曲线，从而在优化模型中实现对非线性满意度的线性模拟。**

## 7. 静态参数文件解析

本节详细介绍模型所依赖的关键静态CSV文件，这些文件为模型提供了重要的业务规则和数据字典。

### 7.1 `calculate/config/disperse_exclude_conf.csv`

*   **作用**: 定义在计算“分散度”指标时需要**排除**的产品类别。
*   **逻辑**: 分散度的目的是评估风险资产是否有效分散。某些低风险、高流动性的资产（如活期存款、国债）本身不具备风险分散功能，它们的存在会干扰分散度指标的准确性。此文件列出的产品类别将在计算分散度得分时被忽略，使分数能更真实地反映风险资产的配置情况。
*   **代码应用**: 程序读取文件中的`三级定义代码`，并将其存为一个排除集合。在构建优化目标时，凡是属于该集合的产品都不会被计入分散度得分的计算中。

### 7.2 `calculate/config/product_priority.csv`

*   **作用**: 定义产品的**交易规则**，特别是控制哪些产品**禁止增持或买入**。
*   **逻辑**: 在实际业务中，并非所有产品都适合推荐给客户，例如某些即将到期或已停售的产品。该文件提供了一个静态的规则表，用于将这些产品排除在购买清单之外。
*   **代码应用**: `product_filter.py` 脚本读取此文件，并筛选出所有`是否允许增持`为“否”的产品类别。在后续处理中，这些类别的产品的`是否可买入`属性会被强制设为 `False`，这会成为优化器必须遵守的一个硬性约束。

### 7.3 `calculate/product_class.csv`

*   **作用**: 作为**产品分类的主数据字典**，定义了从一级到三级以及自定义的完整产品分类体系。
*   **逻辑**: 它的核心价值在于**数据标准化和信息补全**。当处理来自不同源（如产品池、用户持仓）的数据时，分类信息可能不完整或不一致。该文件提供了一个权威的映射表，确保所有产品都能被正确归类。
*   **代码应用**:
    1.  **数据补全**: 在处理用户持仓时，如果一个产品缺少分类信息，程序会使用此文件根据其`三级分类码值`来查找并补全其完整的一级、二级分类名称。
    2.  **数据校验**: 在调试模式下，用于校验输入的产品数据，确保其业务类型与分类定义一致。
    3.  **报告生成**: 在优化完成后生成调仓结果报告时，使用此文件将分类代码转换为可读的分类名称，使报告更易于理解。

## 8. 自动化参数校查 (`ConstraintsCheck`) 工作原理

`ConstraintsCheck` 类是定义在 `calculate/opti_functions.py` 中的一个自动化调试工具。它的核心目标是：当优化器报告“无解”时，自动地、有条理地去**放宽（Relax）**一个或两个约束条件，然后重新尝试求解。如果放宽某个约束后问题解决了，那么程序就可以推断出，很可能是这个被放宽的约束过于严格，导致了最初的失败。

可以把它想象成一个侦探，面对一桩悬案（优化无解），他有一份嫌疑人名单（约束列表），他会先逐一排查（单参数尝试），如果不行，再试试两人共犯（两两参数组合）。

### 工作流程详解

1.  **参数备份 (Initialization)**
    当 `ConstraintsCheck` 被实例化时，它做的第一件事就是接收当前导致失败的所有输入参数，并使用 `copy.deepcopy()` 创建一个完整的**参数备份 (`self.params_bak`)**。这一步至关重要，因为它保证了无论后续的检查如何修改参数，始终都有一个“原始案发现场”的快照，可以随时恢复到最初的状态进行下一次独立的尝试。

2.  **建立“放松策略”清单 (`dicts`)**
    在 `check_all` 方法内部，定义了一个核心的字典 `dicts`。这个字典就是侦探的“嫌疑人档案”和“审讯方法”。
    *   **键 (Key)**: 字典的键是**放松约束的方法**。例如 `self.change_hold_sell`、`self.change_max_num` 等。每一个方法都代表一种“放松”操作，比如 `change_hold_sell` 的作用就是强行将所有持仓产品都设置为“可卖出”。
    *   **值 (Value)**: 字典的值是一个元组，包含两项内容：
        1.  **预设的结论 (Error Message)**: 一个字符串，例如 `"持仓产品中存在无法减配的产品..."`。如果对应的“放松方法”成功解决了问题，这个字符串就会成为返回给用户的结论。
        2.  **详细的诊断报告生成器 (Generator Function)**: 另一个方法引用，例如 `self.gen_msg_for_cannot_hold_sell`。这个方法用于在找到问题根源后，生成更详细、更具体的诊断信息。

3.  **第一轮：单参数尝试 (Single Parameter Trial)**
    这是排查的主要环节。程序会遍历 `dicts` 字典中的每一个“放松策略”。在循环的每一步中：
    *   **执行放松**: 调用“放松方法”（如 `self.change_max_num()`），这会直接修改当前的参数 `self.params`（例如，将最大产品数量上限改为1000）。
    *   **重新求解**: 调用 `self.check_run()`，该函数会使用**被修改过的、更宽松的参数**去重新运行一次完整的优化。
    *   **判断结果**:
        *   **如果优化成功**: 证明刚刚被放宽的那个约束就是“罪魁祸首”。程序会立即记录下预设的结论，并调用关联的“诊断报告生成器”来分析**原始参数**，找出具体是哪个产品或哪个数值导致了约束冲突。最后，组合成完整的错误信息返回，检查过程结束。
        *   **如果优化仍然失败**: 说明这个约束不是问题的唯一原因。程序会调用 `self.prams_restore()` 恢复参数，然后继续循环，尝试下一个“放松策略”。

4.  **第二轮：两两参数组合尝试 (Two-Parameter Combination Trial)**
    如果单参数尝试全部失败，程序会进入第二轮排查：**尝试任意两种约束放松的组合**。它会使用一个嵌套循环，遍历所有可能的“放松方法”的两两组合（例如，同时执行 `change_max_num()` 和 `change_duration()`）。在每次组合放松后，它同样会调用 `check_run()` 重新求解。如果某个组合成功了，程序就会将这两个约束关联的结论信息合并在一起返回。

5.  **最终结论：报告“无结论”**
    如果单参数尝试和两两组合尝试全部失败，`check_all` 方法最终会返回一个空的 `message` 列表。这就是用户遇到的情况，它意味着：**单一或两个约束的放松，都不足以使这个复杂的优化问题变得有解。问题的根源在于更深层次的、多个约束的逻辑性冲突，超出了这个自动化检查工具的能力范围。**