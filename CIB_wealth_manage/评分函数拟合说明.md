# 评分函数拟合规则说明文档

本文档详细说明了 `score_function_fitness` 功能中，针对不同投资评估维度（风险、收益、流动性、分散性）的评分函数拟合规则。

## 核心目标

将业务专家提供的离散的 `(指标, 分数)` 数据点，通过数学优化方法，拟合成一条连续、平滑的数学曲线（函数）。这样做的目的是为了实现评分规则的**参数化、泛化和系统化**，便于在系统中进行高效、统一的计算和调用。

---

## 1. 风险评分 (`volatility_score_function_fitness`)

-   **拟合规则**:
    拟合**波动率**与**风险分数**之间的关系。通常，波动率越高，风险越大，得分越低。该函数呈现为一个单调递减的S型曲线。

-   **入参**:
    -   `x_` (list): 一组波动率的样本值，例如 `[0.05, 0.10, 0.20]`。
    -   `y_` (list): 对应上述波动率样本值得分，范围为0-100，例如 `[80.0, 60.0, 20.0]`。

-   **出参**:
    一个元组 `(func_name, func_content, params, res_min, y_predit)`，包含：
    -   `func_name` (str): 最佳拟合函数的名称, 'tanh_neg'。
    -   `func_content` (str): 最佳拟合函数的数学表达式, '-1*a*tanh(b*x+c)+d'。
    -   `params` (list): 拟合出的最优参数 `[a, b, c, d]`。
    -   `res_min` (float): 拟合的最小损失（误差平方和）。
    -   `y_predit` (list): 使用拟合函数和最优参数计算出的预测分数值。

-   **计算拟合逻辑**:
    1.  **数据预处理**:
        -   将输入的 `y_` (0-100分) 标准化到 0-1 之间。
        -   在数据点中强制加入 `(x=0, y=1)`，确保零波动率对应满分。
        -   在数据末尾额外添加几个 `x` 值更大、`y` 值递减的点，以引导函数曲线在末端的收敛行为。
        -   设置权重 `w`，对起始的几个点给予更高权重，确保拟合曲线的起点正确。
    2.  **函数模型**:
        -   选用 `tanh_neg` 函数: `y = -a * np.tanh(b * x + c) + d`。这是一个反向的S型曲线，非常适合描述得分随风险增加而下降的场景。
    3.  **优化过程**:
        -   使用 `scipy.optimize.minimize` 在多种优化算法（如 `SLSQP`, `Powell` 等）中进行迭代。
        -   优化的目标是找到一组参数 `[a, b, c, d]`，使得模型预测值与（预处理后的）真实值之间的加权平方误差 (`obj_func2`) 最小。
        -   `obj_func2` 包含惩罚项，如果预测值超出了 `[0, 1]` 的范围，误差会急剧增大，保证分数的有效性。
    4.  **后处理**:
        -   从所有成功的优化算法结果中，选择误差最小的那一个。
        -   将得到的最优参数 `a` 和 `d` 乘以100，还原到0-100的评分范围。

---

## 2. 收益评分 (`return_score_function_fitness`)

-   **拟合规则**:
    拟合**预期收益率**与**收益分数**之间的关系。通常，收益率越高，得分越高，但得分的增长速度会放缓（边际效用递减），呈现为一个标准的S型曲线。

-   **入参**:
    -   `x_` (list): 一组预期收益率的样本值。
    -   `y_` (list): 对应得分（0-100）。

-   **出参**:
    与风险评分类似，包含 `(func_name, func_content, params, fmin, y_predit)`。

-   **计算拟合逻辑**:
    1.  **数据预处理**:
        -   强制加入 `(x=0, y=0)` 点，确保零收益零分。
        -   强制加入一个远端点 `(x=x[-1]*10, y=100)`，确保曲线最终能收敛到100分。
        -   设置权重 `w`，对用户输入的第二个点给予双倍权重，以确保曲线能精确穿过一个关键的中间点。
    2.  **函数模型**:
        -   选用 `morgan_mercer_flodin` 函数: `y = (b * c + a * x^d) / (c + x^d)`。这是一个灵活的S型生长曲线模型。
    3.  **优化过程**:
        -   **网格搜索 (Grid Search)**: 与 `minimize` 不同，这里采用了网格搜索。
        -   它预先定义了参数 `a, b, c, d` 可能的取值范围，然后通过 `itertools.product` 遍历所有参数组合。
        -   对每一种组合，计算其总误差 (`obj_func`)，并保留误差最小的那组参数。
        -   为了提高精度，该过程会迭代执行，在上一轮找到的最佳参数 `c` 附近进行更精细的搜索。

---

## 3. 流动性评分 (`cash_score_function_fitness`)

-   **拟合规则**:
    拟合**现金或高流动性资产占比**与**流动性分数**之间的关系。这通常也是一个S型曲线。

-   **入参**:
    -   `x_` (list): 一组现金占比的样本值。
    -   `y_` (list): 对应得分（0-100）。

-   **出参**:
    与风险评分类似，包含 `(func_name, func_content, params, res_min, y_predit)`。

-   **计算拟合逻辑**:
    1.  **数据预处理**:
        -   对数据点进行简单的清洗，避免点与点之间过于接近。
    2.  **函数模型**:
        -   选用 `atan` (反正切) 函数: `y = a * np.arctan(b * x + c) + d`。`arctan` 也是一种S型曲线。
    3.  **优化过程**:
        -   与风险评分类似，使用 `scipy.optimize.minimize` 和多种优化算法进行迭代。
        -   使用固定的初始参数 `x0` 作为优化的起点。
        -   优化的目标是找到最小化 `obj_func` (平方误差和) 的参数 `[a, b, c, d]`。

---

## 4. 分散性评分 (`disperse_score_function_fitness`)

-   **拟合规则**:
    拟合**资产分散度指标**（如 HHI 指数的变种）与**分散性分数**之间的关系。

-   **入参**:
    -   `x_` (list): 一组分散度指标的样本值。
    -   `y_` (list): 对应得分（0-100）。

-   **出参**:
    与收益评分类似，包含 `(func_name, func_content, params, fmin, y_predit)`。

-   **计算拟合逻辑**:
    1.  **函数模型**:
        -   与收益评分一样，选用 `morgan_mercer_flodin` 函数: `y = (b * c + a * x^d) / (c + x^d)`。
    2.  **优化过程**:
        -   采用大规模的**网格搜索**。
        -   为参数 `a, b, c, d` 定义了非常广泛的搜索空间，通过遍历所有组合来寻找全局最优解。这是一种暴力但有效的方法，适用于 `minimize` 可能陷入局部最优的情况。

---

## 5. 分散度价值函数拟合 (`disperse_value_function_fitness`)

-   **拟合规则**:
    这是一个内部辅助函数，**不用于拟合用户输入**。它的目标是使用一个简单的**二次函数 (`a*x^2 + b*x`)** 去近似**信息熵的核心部分 (`-x * log(x)`)**。在计算分散度时（如HHI指数），经常会用到 `-sum(w_i * log(w_i))`，将其近似为二次函数可以极大简化下游的优化问题。

-   **入参**:
    无。

-   **出参**:
    元组，包含函数名 'quadratic'、表达式 "a*x^2+b*x"、最优参数 `[a, b]` 等信息。

-   **计算拟合逻辑**:
    1.  **数据生成**: 在 `[0, 1]` 区间内生成100个点，计算出 `y = -x * log(x)` 的值，作为拟合的目标数据。
    2.  **函数模型**:
        -   选用 `quadratic` 函数: `y = a * x^2 + b * x + c` (代码中 `c` 固定为0)。
    3.  **优化过程**:
        -   使用 `scipy.optimize.minimize` 和一组精选的优化算法（`Powell`, `CG` 等）来寻找最佳的 `a` 和 `b`。
